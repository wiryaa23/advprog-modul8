# Module 8 Tutorial: High-Level Networking

Wirya Dharma Kurnia - 2306152115

### Reflection
1. What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?

> Unary, server streaming, dan bi-directional streaming RPC adalah tiga pola komunikasi berbeda dalam gRPC yang ditentukan dari bagaimana data dikirim dan diterima antara client dan server. Pada unary RPC, client mengirim satu request dan server juga membalas dengan satu response. Pola ini cocok untuk request sederhana seperti mengambil data user dengan ID. Pada server streaming RPC, client mengirim satu request dan server membalas dengan mengirim banyak response secara bertahap. Pola ini cocok mengirim data yang sifatnya seperti log aktivitas atau riwayat transaksi. Sedangkan pada bi-directional RPC, client dan server saling bertukar banyak pesan secara bersamaan dalam satu koneksi seperti streaming dua arah. Pola ini cocok untuk aplikasi real-time seperti fitur chat.

2. What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?

> Ada beberapa pertimbangan keamanan utama ketika mengimplementasikan gRPC di Rust. Pertama, autentikasi dibutuhkan agar server dapat memastikan bahwa request yang dikirimkan berasal dari pengguna yang sah. Hal tersebut dapat dilakukan dengan menggunakan token JWT atau dengan TLS mutual authentication. Kedua, otorisasi berfungsi untuk membatasi hak akses berdasarkan role pengguna. Ini bisa dilakukan dengan memastikan bahwa hanya pengguna yang berhak yang dapat mengakses fitur tertentu, khususnya dengan pengecekan izin di middleware sebelum memproses request. Sementara enkripsi data merupakan hal yang wajib sifatnya dalam komunikasi client dan server. Implementasinya dapat menggunakan TLS untuk mengenkripsi komunikasi antara client dan server agar tetap aman selama proses perpindahan data.

3. What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?

> Ketika menangani bidirectional streaming di Rust gRPC khususnya untuk skenario seperti chat dalam aplikasi, ada beberapa potensi tantangan dan isu yang muncul. Contoh pertama misalnya dalam hal sinkronisasi dan konkurensi, di mana untuk mengelola pengiriman dan penerimaan pesan kita memerlukan async yang tepat agar pesan tidak tertukar dan lebih parahnya dapat berakibat pada deadlock atau race condition. Contoh lainnya adalah dalam hal manajemen state, seperti penyimpanan dan pengelolaan status user bisa menjadi kompleks. Selain itu ada juga dalam hal error handling khususnya jika koneksi terputus secara tiba-tiba, harus ada mekanisme untuk retry atau deteksi disconnect agar aplikasi tetao stabil. Adapun dalam hal backpressure, di mana kita perlu mengontrol arus pesan agar server atau client tidak kewalahan ketika menerima terlalu banyak data sekaligus. Tantangan lainnya misalnya mencegah terjadinya memory leak yang diakibatkan oleh penutupan channel yang tidak benar. Karena itu, penerapan strategi dalam tahap pengembangan akan sangat berpengaruh pada performa aplikasi.

4. What are the advantages and disadvantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?

> Penggunaan tokio_stream::wrappers::ReceiverStream dalam layanan gRPC streaming di Rust memiliki beberapa keuntungan. Salah satunya adalah kemudahan dalam mengubah tokio::mpsc::Receiver menjadi stream yang langsung kompatibel dengan tonic, sehingga mempermudah pengiriman data secara bertahap tanpa perlu mengimplementasikan trait Stream sendiri. Karena berjalan di atas Tokio, ReceiverStream juga mendukung eksekusi asynchronous secara alami dan mudah diintegrasikan dengan task atau runtime lainnya. Selain itu, server memiliki kontrol penuh terhadap kapan data dikirim melalui channel. Namun, terdapat beberapa kelemahan seperti terbatasnya buffer, sehingga jika receiver lambat, pesan bisa tertunda atau bahkan terblokir. Penanganan error juga tidak otomatis, misalnya jika Sender ditutup secara tiba-tiba stream bisa berhenti tanpa informasi yang jelas. Sifatnya yang satu arah turut membatasi fleksibilitas komunikasi, terutama bila aplikasi memerlukan respon atau kontrol aliran data yang lebih kompleks.

5. In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?

> Untuk memastikan kode Rust gRPC tetap modular, dapat digunakan kembali, dan mudah dikembangkan, kita harus merancang struktur proyek dengan pemisahan tanggung jawab yang jelas. Pertama komponen seperti definisi layanan gRPC, logika bisnis, dan layer komunikasi sebaiknya dipisah ke dalam modul atau folder berbeda, sehingga perubahan di satu bagian tidak memengaruhi bagian lain. Kedua, penggunaan trait sangat berguna untuk mendefinisikan perilaku service handler, sehingga implementasi bisa diuji atau diganti dengan lebih fleksibel. Pendekatan seperti pemisahan layer ke dalam service, handler, repository, dan model, serta pemanfaatan modul-modul Rust berdasarkan domain fitur atau jenis komunikasi, akan sangat membantu dalam navigasi proyek berskala besar. File `.proto` juga sebaiknya dipisah dalam direktori tersendiri, dan hasil generate-nya dimasukkan ke modul khusus agar tidak tercampur dengan logika aplikasi. Selain itu, menggunakan dependency injection manual (dengan meneruskan dependensi melalui constructor) akan memudahkan proses testing dan maintenance. Arsitektur seperti ini akan meningkatkan maintainability dan extensibility seiring pertumbuhan aplikasi.

6. In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic?

> Untuk menangani proses pembayaran yang lebih kompleks dalam MyPaymentService, kita dapat mengimplementasikan beberapa langkah tambahan seperti validasi data input secara menyeluruh, pengecekan saldo atau status akun melalui database, serta pencatatan transaksi secara konsisten. Selain itu, integrasi dengan layanan eksternal seperti gateway pembayaran, sistem antifraud, atau bank juga penting untuk mendukung proses nyata. Adapun penanganan error seperti timeout, gangguan jaringan, atau transaksi ditolak perlu ditangani secara eksplisit, serta dilengkapi dengan mekanisme retry dan pemberian respons yang tepat ke client. Untuk menjamin keamanan dan audit, kita perlu melakukan proses logging, monitoring, serta enkripsi data sensitif. Penggunaan idempotency key juga disarankan untuk mencegah transaksi ganda, dan concurrency control dibutuhkan agar data tetap konsisten saat permintaan datang secara bersamaan. Struktur seperti ini akan meningkatkan keandalan dan skalabilitas layanan pembayaran.

7. What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?

> Penggunaan gRPC dalam sistem terdistribusi memberikan dampak terhadap arsitektur dan interoperabilitas. Dengan memanfaatkan Protocol Buffers sebagai format data, gRPC memungkinkan komunikasi lintas bahasa dan platform hanya dengan mendefinisikan kontrak layanan di satu file `.proto`. Hal ini menyederhanakan integrasi antar layanan yang dibangun dengan teknologi berbeda. Selain itu, gRPC berjalan di atas HTTP/2 yang mendukung multiplexing dan koneksi persisten, sehingga ia menjadi ideal untuk sistem microservices yang membutuhkan komunikasi efisien dan real-time. Namun, kita harus memperhatikan ketika harus berinteraksi dengan sistem yang tidak mendukung HTTP/2 atau Protobuf. Karena itu, dibutuhkan tambahan seperti gRPC-Gateway untuk menjembatani komunikasi dengan client berbasis REST.

8. What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?

> HTTP/2 memiliki beberapa kelebihan dibanding HTTP/1.1 maupun HTTP/1.1 dengan WebSocket, terutama untuk kebutuhan komunikasi backend seperti gRPC. Fitur utamanya adalah multiplexing yang memungkinkan banyak request dan response dikirim secara paralel melalui satu koneksi, sehingga mengurangi latensi dan meningkatkan efisiensi. Selain itu, HTTP/2 mendukung kompresi header, koneksi persisten, serta streaming dua arah secara native. Semua ini membuat HTTP/2 menjadi opsi yang baik untuk sistem real-time dan layanan intensif data. Namun, penggunaan HTTP/2 juga memiliki kekurangan seperti kompleksitas implementasi yang lebih tinggi, kesulitan dalam proses debugging, serta ketergantungan pada kestabilan koneksi karena semua komunikasi terjadi dalam satu saluran. Selain itu, kompatibilitas dengan alat lama dan kebutuhan TLS juga bisa menjadi hambatan. Kemudian untuk interaksi dengan frontend berbasis web, sering kali kita membutuhkan gateway tambahan karena browser tidak mendukung gRPC secara langsung.

9. How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?

> Model komunikasi REST API yang bersifat sinkron dan satu arah mengharuskan client menunggu respons dari server setiap kali mengirim permintaan. Karena itu, ia kurang optimal untuk aplikasi real-time karena setiap interaksi memerlukan permintaan baru atau polling berkala. Sebaliknya, gRPC mendukung bidirectional streaming sehingga memungkinkan client dan server bertukar pesan secara terus-menerus dalam satu koneksi terbuka. Pendekatan ini memberikan latensi rendah dan efisiensi tinggi sehingga cenderung ideal untuk skenario seperti chat, monitoring sistem, atau live updates, di mana komunikasi dua arah secara simultan sangat dibutuhkan tanpa perlu membangun ulang koneksi.

10. What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?

> Pendekatan schema-based seperti yang digunakan oleh gRPC dengan Protocol Buffers memberikan struktur data yang eksplisit dan terstandarisasi. Hal ini mempermudah validasi, auto-generasi kode, serta menjamin konsistensi antara client dan server. Format biner yang dihasilkan juga lebih efisien dalam hal ukuran dan kecepatan parsing,sehingga cocok untuk sistem berskala besar yang memerlukan komunikasi antar layanan dengan kontrak data yang kuat. Namun, pendekatan ini cenderung lebih kaku karena setiap perubahan pada skema membutuhkan kompilasi ulang. Di sisi lain, REST API yang menggunakan JSON lebih fleksibel karena tidak bergantung pada skema yang sifatnya tetap, sehingga memudahkan perubahan cepat tanpa proses build ulang. Meski begitu, fleksibilitas ini juga membawa risiko ketidaksesuaian format dan kesulitan dalam validasi yang dapat memicu bug jika tidak ditangani secara hati-hati.
